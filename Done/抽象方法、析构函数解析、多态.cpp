#include <iostream>



/*********************************************
抽象方法 == 纯虚函数
把某个方法声明为一个抽象方法等于告诉编译器这个方法必不可少，但我现在
(在这个基类里)还不能为它提供一个实现。
有了抽象方法，这样我们就用不着编写那些不必要的代码

抽象方法语法很简单：在声明一个虚方法的基础上，在原型的末尾加上
“ = 0 ”即可。（告诉编译器不要浪费时间在这个类里寻找这个方法的实现）

析构函数解析：
析构器都是虚方法，是为了当一个基类的指针删除一个派生类的对象时，
派生类的析构函数可以被正确使用。当类里面有虚函数的时候，编译器会给
类添加一个虚函数表，里面存放着虚函数的指针。为了节省资源，只有当一个
类被用来作为基类的时候，我们才会把析构函数写成虚函数！

多态！
多态的目的：封装可以使得代码模块化，继承可以扩展已存在的代码，
他们的目的都是为了代码重用。而多态的目的则是为了“接口重用”。也即，
不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应
各自对象的实现方法。
多态最常见的用法就是声明基类类型的指针，利用该指针指向任意一个子类
对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。
如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应
的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过
的函数。因为没有多态性，函数调用的地址将是固定的，因此将始终调用到
同一个函数，这就无法实现“一个接口，多种方法”的目的了

*********************************************/


class Pet
{
public:
    Pet();
    virtual ~Pet();     //将基类里的析构函数声明为虚函数
    void eat(){};
    virtual void play() =0; //基类里不用的函数声明为纯虚函数

};

    Pet::Pet()
    {

    };

    Pet::~Pet()
    {
        std::cout<<"Pet destructor!\n"<<std::endl;
    }

class Dog : public Pet
{
public:
    Dog(){};
    ~Dog()
    {
        std::cout<<"Dog destructor!\n"<<std::endl;
    }

    void play()
    {

        std::cout<<"Dog playing!\n"<<std::endl;
    }

};

class Cat : public Pet
{
public:
    Cat(){};
    ~Cat()
    {
        std::cout<<"Cat destructor!\n"<<std::endl;
    }

    void play()
    {

        std::cout<<"Cat playing!\n"<<std::endl;
    }

};

void DoSpeak(Pet & pet)
{
    pet.play();
}



int main()
{

    Pet *dog = new Dog; //声明基类类型的指针。多态的用法！
                        //多态要和虚函数搭配使用！
    dog->play();

//一定要记得加上delete代码！ 否则内存不会释放的！
//delete之后，会先执行子类的析构，再执行基类的析构
//如果基类的析构不声明为虚函数，那么只会执行基类的析构，
//而子类的析构函数不执行，也就意味着子类的内存没有释放！
//这样会造成内存泄漏，所以基类都要用虚函数析构器
    delete dog; 

    Pet *cat = new Cat; //声明基类类型的指针。多态的用法！
                        //多态要和虚函数搭配使用！
    cat->play();    

    delete cat;     

    Dog dog1;
    Cat cat1;
    DoSpeak(dog1);
    DoSpeak(cat1);



    return 0;
}
